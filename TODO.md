# TODO (отладка селекторов) — модульная структура

Ниже перечислены найденные проблемы, сгруппированные по модулям и функциям, а также рекомендации по их устранению. Формулировки краткие и прикладные, чтобы использовать как чек‑лист.

Модуль: html_fragment.py

- find_elements_by_text
  - Статус: корректно нормализует пробелы при exact=True. Проблем явных не выявлено.
  - Рекомендации:
    - Уточнить докстринг: явно описать нормализацию пробелов и влияние case_sensitive.

- find_text_nodes
  - Статус: логика поиска согласована с find_elements_by_text; проблем явных не выявлено.
  - Рекомендации:
    - Аналогично: уточнить докстринг по нормализации/регистру.
- lowest_common_ancestor
  - Статус: алгоритм корректен, исключает [document]; проблем явных не выявлено.
- extract_common_parent_html
  - Статус: корректная поддержка search_mode/text и element, all_matches, verbose. Существенных дефектов не найдено.
  - Рекомендации:
    - Добавить краткую заметку в докстринг про исключение body/html/[document] и дедупликацию по id().

- extract_common_parent_from_url
  - ✅ Проблема: отсутствует timeout у requests.get — возможны зависания. **Исправлено**: добавлен timeout=10 по умолчанию.
  - Проблема: дублирование интерфейса use_selenium/driver c extract_common_parent_from_driver — избыточная сложность.
  - Рекомендации:
    - Обрабатывать RequestException, логировать и возвращать пустой список/пробрасывать осмысленную ошибку.
    - Рассмотреть упрощение интерфейса: этот путь — только requests; Selenium — только через extract_common_parent_from_driver.

- extract_common_parent_from_driver
  - Статус: обертка над extract_common_parent_html; проблем явных не выявлено.


Модуль: debug_selectors.py

- parse_arguments
  - Проблема: нестандартный дизайн — функция принимает внешние default-ы, что усложняет обычный CLI.
  - Рекомендации:
    - Перейти к стандартной схеме argparse (значения по умолчанию внутри функции). Тестовый режим — через --test.

- get_test_data_to_parse / get_test_data_to_search
  - ✅ Проблема: неверные аннотации типов (указаны dict[str, list[tuple[str,str]]], фактически возвращают List[Dict[label,value]]). **Исправлено**: сигнатура исправлена на Dict[str, List[Dict[str, str]]].
  - Рекомендации:
    - Рассмотреть введение TypedDict (LabelValuePair).

- run_parse
  - ✅ Критичный баг: при args.test=False собирается search_data = {url: [(label, value)]}, но далее код ожидает pair['label'] — упадет с TypeError. **Исправлено**: формат изменён на {url: [{'label': ..., 'value': ...}]}.
  - ✅ Добавлена фильтрация пустых фрагментов (при отсутствии найденных фрагментов пара не добавляется в all_fragments).
  - Рекомендации:
    - Уточнить тип возвращаемого значения (сейчас аннотация Union[bool, list[str]] не соответствует фактической структуре кортежей с resource).

- search_web
  - Проблема: фиксированный time.sleep(5) вместо явных ожиданий Selenium.
  - Проблема: при is_driver=False переданный driver игнорируется без предупреждения — возможна путаница.
  - Рекомендации:
    - Использовать WebDriverWait/ExpectedConditions для ожиданий (например, загрузка body или появления узлов).
    - Явно валидировать комбинацию флагов: если driver передан, а is_driver=False — выдавать предупреждение/log.

- generate_pattern
  - ✅ Проблема: некорректные аннотации (parse_frags: str; -> возвращает List[Dict], а объявлен Dict). **Исправлено**: сигнатура исправлена на Iterable[Tuple[...]] -> List[Dict[str, Any]].
  - ✅ Добавлена проверка на пустые фрагменты (пропуск с предупреждением).
  - Проблема: используется только fragments[0]; остальные фрагменты игнорируются.
  - Проблема: CSS «уникальный класс» проверяется в пределах всего soup, а collect_unique_classes — внутри ancestor (несогласованность критериев).
  - Проблема: XPath строится через contains(text(), '...') без нормализации (рассинхрон с exact/normalize в поиске).
  - Проблема: эвристика выбора атрибута для <a> (text vs href) может давать неверный выбор.
  - Проблема: сложная логика подъема ancestor при пустом label может увести слишком высоко.
  - Рекомендации:
    - Итерироваться по всем fragments и формировать альтернативные паттерны (с приоритизацией).
    - Унифицировать критерий уникальности классов: проверять уникальность внутри ancestor (или документировать выбор «по всему фрагменту» и применять его в collect_unique_classes).
    - Генерировать нормализованные XPath: normalize-space(.), при case-insensitive — через translate(., 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'). Для exact — полное сравнение normalize-space(.) = '...' (с учетом регистра).
    - Параметризовать выбор атрибута (text/href/src/content) через аргумент/конфиг; по умолчанию — text для <a>, если значение совпадает.
    - Ограничить подъем ancestor при пустом label: не подниматься до html/body; ограничить числом уровней; останавливать на первом элементе с id/class.

- extract_value
  - ✅ Проблема: вводящий в заблуждение комментарий «pass» в ветке XPath/lxml. **Исправлено**: комментарий заменён на поясняющий, поведение уточнено.
  - Рекомендации:
    - Уточнить типы (возвращает Optional[str]).

- run_search
  - ✅ Проблема: прямой requests.get без timeout и без объединения заголовков (в отличие от html_fragment.DEFAULT_HEADERS). **Исправлено**: добавлен timeout=10, заголовки User-Agent.
  - Проблема: выбор паттерна по индексу пары (idx) — хрупко (порядок полей может не совпадать).
  - Рекомендации:
    - Маппить паттерны по ключам (label/value) и resource_id; подбирать по совпадению label/value, а не по позиции.
    - Обрабатывать RequestException с понятным логом.

- main
  - Проблема: нестандартный вызов parse_arguments с внешним default_arg_values ломает обычный CLI UX.
  - Рекомендации:
    - Перейти на стандартный CLI, оставить --test, а значения по умолчанию задавать внутри parse_arguments.

Сквозные задачи (общие для модулей)
- Конфигурация таймаутов
  - Добавить в ScraperConfig параметры timeout для HTTP и Selenium-ожиданий; прокинуть их в вызовы requests/WebDriverWait.
- Тестовое покрытие (минимальный набор регресс‑тестов)
  - Пустой label (value‑only), оба режима поиска (text/element), exact=True/False, case_sensitive=True/False.
  - Нормализация пробелов (многострочный текст, лишние пробелы).
  - <a>: извлечение text vs href по параметру.
  - run_parse: режим без test (устранение бага формата пары).
  - Обработка RequestException/таймаутов; Selenium ожидания без sleep.

Приоритетный план работ (итерации)
- Итерация 1 (без изменения логики поиска) — **ВЫПОЛНЕНО**:
  - ✅ Исправить критичный баг в run_parse (формат пары в не‑test режиме).
  - ✅ Добавить timeout в requests (html_fragment.extract_common_parent_from_url, debug_selectors.run_search).
  - ✅ Удалить вводящий «pass» в extract_value и уточнить поведение.
  - ✅ Исправить аннотации типов в тестовых данных и generate_pattern.
  - ✅ Обработка исключений при поиске отсутствующих полей (добавлена проверка пустых фрагментов).
- Итерация 2 (устойчивость и ожидаемость) — **ВЫПОЛНЕНО**:
  - ✅ Заменить sleep на WebDriverWait в search_web (реализована функция wait_for_page_with_protection).
  - ✅ Нормализовать XPath в generate_pattern (добавлена функция build_xpath_text_condition с поддержкой normalize-space/translate).
  - ✅ Перейти на маппинг паттернов по label/value в run_search (реализована функция find_best_pattern).
- Итерация 3 (качество/UX):
  - Унифицировать критерии уникальности классов; расширить генерацию по всем фрагментам.
  - Параметризовать выбор атрибутов (text/href/src) и описать в докстрингах/CONCEPTION.md.
  - Перейти на стандартный CLI для parse_arguments.
