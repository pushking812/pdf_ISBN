# План рефакторинга `debug_selectors.py`

## Текущие проблемы

1. **Аргументы argparse противоречивы**:
   - `--exact` имеет `default=True` при `action='store_true'`, что делает флаг всегда активным.
   - `--verbose` также `default=True`, что не соответствует стандартному поведению флагов.

2. **Игнорирование пользовательских аргументов**:
   - Позиционные аргументы `url`, `label`, `value` имеют значения по умолчанию, но внутри скрипта используется жёстко закодированный словарь `search_data`.

3. **Ошибка области видимости переменной `fragments`**:
   - Переменная `fragments` определяется внутри циклов, но используется после них, что может привести к `NameError`, если цикл не выполнился.

4. **Дублирование вывода фрагментов**:
   - Фрагменты выводятся внутри цикла и после цикла, что приводит к двойному выводу.

5. **Низкая читаемость**:
   - Смешанные отступы, длинные строки, недостаток комментариев.

6. **Отсутствие типизации**:
   - Нет аннотаций типов, что усложняет анализ кода.

7. **Избыточный путь импорта**:
   - `sys.path.insert(0, "..")` не нужен, так как все модули находятся в той же директории.

## Предлагаемые изменения

### 1. Исправление аргументов argparse

- `--exact`: изменить на `default=False`, `action='store_true'`. По умолчанию ищется частичное совпадение, флаг включает точное совпадение.
- `--verbose`: изменить на `default=False`, `action='store_true'`. По умолчанию отладочная информация не выводится.
- Добавить флаг `--test` (`action='store_true'`), который включает использование тестового набора данных (словарь `search_data`).

### 2. Использование пользовательских аргументов или тестовых данных

- Если указан флаг `--test`, использовать жёстко закодированный словарь `search_data`.
- Иначе использовать переданные `url`, `label`, `value` (даже если они равны значениям по умолчанию).
- Убрать циклы по словарю, оставить обработку одной пары (либо нескольких пар в тестовом режиме).

### 3. Устранение ошибки области видимости

- Определить переменную `fragments` в той же области, где она используется (например, результат вызова `extract_common_parent_...`).
- Обеспечить, чтобы `fragments` всегда была определена (пустой список, если ничего не найдено).

### 4. Устранение дублирования вывода

- Выделить функцию `print_fragments(fragments)`, которая выводит фрагменты единообразно.
- Убрать вывод внутри циклов, вызывать `print_fragments` только после получения всех фрагментов.

### 5. Улучшение читаемости

- Привести отступы к 4 пробелам (PEP 8).
- Разделить длинные строки (например, строки help в argparse).
- Добавить комментарии на русском к ключевым блокам.
- Отформатировать код с помощью `black` (опционально).

### 6. Добавление типизации

- Добавить импорты из `typing`: `List`, `Optional`, `Tuple` и т.д.
- Аннотировать функцию `main()` и все вспомогательные функции.
- Аннотировать локальные переменные, где это уместно.

### 7. Удаление лишнего пути импорта

- Удалить строку `sys.path.insert(0, "..")`.
- Убедиться, что все импорты (`html_fragment`, `drivers`, `config`) работают без неё.

### 8. Полное разбиение на вспомогательные функции

Предлагается следующая структура:

```python
def parse_arguments() -> argparse.Namespace:
    """Парсинг аргументов командной строки."""

def get_test_data() -> Dict[str, List[Tuple[str, str]]]:
    """Возвращает тестовый набор данных (словарь URL -> список пар)."""

def create_driver(config: ScraperConfig) -> WebDriver:
    """Создаёт и возвращает экземпляр ChromeDriver."""

def search_with_selenium(
    driver: WebDriver,
    url: str,
    label: str,
    value: str,
    exact_label: bool,
    exact_value: bool,
    case_sensitive: bool,
    all_matches: bool,
    verbose: bool,
    search_mode: str,
) -> List[str]:
    """Выполняет поиск фрагментов с использованием Selenium."""

def search_with_requests(
    url: str,
    label: str,
    value: str,
    exact_label: bool,
    exact_value: bool,
    case_sensitive: bool,
    all_matches: bool,
    verbose: bool,
    search_mode: str,
) -> List[str]:
    """Выполняет поиск фрагментов с использованием requests + BeautifulSoup."""

def print_fragments(fragments: List[str]) -> None:
    """Выводит найденные фрагменты в консоль."""

def run_search(args: argparse.Namespace) -> List[str]:
    """Координирует процесс поиска на основе аргументов."""

def main() -> None:
    """Основная точка входа."""
```

## Пример вызова после рефакторинга

```bash
# Использование пользовательских данных
python debug_selectors.py https://example.com/book "Год издания" "2020" --selenium --exact

# Использование тестовых данных
python debug_selectors.py --test --selenium

# Без Selenium, с частичным совпадением
python debug_selectors.py https://example.com/book "Авторы" "Иванов" --verbose
```

## Порядок реализации

1. Создать копию оригинального файла для безопасности.
2. Внести исправления последовательно, следуя пунктам плана.
3. После каждого изменения запускать скрипт с тестовыми данными, чтобы убедиться в отсутствии регрессий.
4. Проверить типизацию с помощью `mypy` (если установлен).
5. Проверить соответствие PEP 8 с помощью `ruff` или `black`.

## Ожидаемый результат

- Скрипт становится предсказуемым: аргументы командной строки работают как описано в help.
- Устранены критические ошибки (NameError, дублирование вывода).
- Код хорошо структурирован, легко читается и может быть расширен в будущем.
- Сохранена обратная совместимость за счёт флага `--test`.