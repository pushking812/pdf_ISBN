# План разработки функций для генерации и применения паттернов в debug_selectors.py

## Цель
Разработать две функции:
1. `generate_pattern` – получает фрагмент HTML для пары ключевое поле/значение, подготавливает и возвращает универсальный паттерн для однозначного получения значения ключевого поля со страницы конкретного ресурса.
2. `extract_value` – получает созданный паттерн и на его основании получает со страницы книги значения ключевого поля.

## Требования
- Паттерн должен быть универсальным для ресурса (работать на разных страницах одного сайта).
- Поддержка извлечения через Selenium (драйвер) и через статический HTML.
- Возможность использовать как CSS-селекторы, так и XPath.
- Интеграция с существующим кодом `debug_selectors.py`.

## Предлагаемый алгоритм

### Функция `generate_pattern(fragment_html: str, label_text: str, value_text: str, search_mode: str = "text") -> dict`

1. **Парсинг фрагмента**
   - Использовать `BeautifulSoup(fragment_html, "lxml")`.
   - Найти узлы, содержащие `label_text` и `value_text`, с помощью функций `find_text_nodes` или `find_elements_by_text` из модуля `html_fragment` (уже импортированы).

2. **Определение структурного отношения**
   - Найти общего предка (LCA) для найденных узлов (уже есть функция `lowest_common_ancestor` в `html_fragment`).
   - Определить путь от общего предка к узлу значения.

3. **Построение селектора**
   - **Проверка уникальности атрибутов**: проверить, есть ли у узла значения уникальный класс, id или data-атрибут, который не встречается у других элементов внутри фрагмента. Если да – построить CSS-селектор по этому атрибуту.
   - **Иначе построить XPath**:
     - Определить отношение между узлом label и значением (например, значение является следующим соседом, дочерним элементом и т.д.).
     - Построить XPath вида `//*[contains(text(), label_text)]/following-sibling::*[contains(@class, 'value-class')]` или аналогичный.
   - **Резервный вариант**: если уникальных атрибутов нет и отношение не удалось определить, вернуть CSS-селектор по классу с привязкой к label через `:has` (для BeautifulSoup) или XPath с текстовым условием.

4. **Определение атрибута для извлечения**
   - Если значение хранится в текстовом узле – атрибут `"text"`.
   - Если значение – это ссылка (`<a href="...">`), атрибут `"href"`.
   - Автоматически определить по тегу и атрибутам.

5. **Возвращаемый формат**
   ```python
   {
       "type": "css" | "xpath",
       "selector": str,
       "attribute": str,  # "text", "href", "src", etc.
       "clean_regex": Optional[str],  # регулярное выражение для очистки значения
       "label_text": label_text,
       "value_text": value_text
   }
   ```

### Функция `extract_value(html_or_driver, pattern, use_selenium=False)`

1. **Определение типа входных данных**
   - Если `html_or_driver` является экземпляром `WebDriver` – использовать Selenium.
   - Если это строка – использовать статический парсинг.

2. **Применение паттерна**
   - **CSS-селектор**:
     - Selenium: `driver.find_element(By.CSS_SELECTOR, pattern["selector"])`
     - BeautifulSoup: `soup.select_one(pattern["selector"])`
   - **XPath**:
     - Selenium: `driver.find_element(By.XPATH, pattern["selector"])`
     - lxml: `tree.xpath(pattern["selector"])[0]` (требуется конвертация HTML в lxml).

3. **Извлечение значения**
   - Если `attribute == "text"` – получить текст элемента.
   - Иначе – получить атрибут элемента.

4. **Очистка**
   - Применить `clean_regex` (если указан) для извлечения части текста.
   - Удалить лишние пробелы, нормализовать.

5. **Возврат значения** или `None` в случае ошибки.

### Интеграция с debug_selectors.py
- Добавить новые функции в конец файла (перед `main`).
- Расширить существующий CLI для возможности тестирования паттернов (опционально).
- Использовать уже импортированные модули (`BeautifulSoup`, `html_fragment`).

## План реализации

1. **Подготовка**
   - Изучить структуру фрагментов для разных ресурсов (book.ru, РГБ, Читай-город).
   - Написать вспомогательные функции для анализа уникальности атрибутов.

2. **Реализация `generate_pattern`**
   - Написать функцию определения уникального атрибута.
   - Реализовать построение CSS-селектора.
   - Реализовать построение XPath.
   - Протестировать на примерах фрагментов.

3. **Реализация `extract_value`**
   - Реализовать поддержку Selenium и статического HTML.
   - Добавить обработку ошибок.

4. **Интеграция и тестирование**
   - Добавить функции в `debug_selectors.py`.
   - Написать unit-тесты в `tests/test_debug_selectors.py`.
   - Проверить работу на реальных страницах.

5. **Документация**
   - Добавить docstrings на русском языке.
   - Обновить README или комментарии в коде.

## Ожидаемые сложности
- Определение уникальности атрибутов в пределах всего документа (а не только фрагмента).
- Генерация стабильных селекторов, которые не ломаются при небольших изменениях вёрстки.
- Поддержка XPath в BeautifulSoup (может потребоваться установка lxml и использование `soup.xpath`).

## Следующие шаги
После утверждения плана переключиться в режим Code и приступить к реализации.